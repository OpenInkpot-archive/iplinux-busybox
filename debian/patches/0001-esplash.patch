diff --git a/include/applets.h b/include/applets.h
index 46135dc..4a7a3b1 100644
--- a/include/applets.h
+++ b/include/applets.h
@@ -139,6 +139,7 @@ USE_EJECT(APPLET(eject, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_ENV(APPLET(env, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_ENVDIR(APPLET_ODDNAME(envdir, chpst, _BB_DIR_USR_BIN, _BB_SUID_NEVER, envdir))
 USE_ENVUIDGID(APPLET_ODDNAME(envuidgid, chpst, _BB_DIR_USR_BIN, _BB_SUID_NEVER, envuidgid))
+USE_ESPLASH(APPLET(esplash, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_ETHER_WAKE(APPLET_ODDNAME(ether-wake, ether_wake, _BB_DIR_USR_BIN, _BB_SUID_NEVER, ether_wake))
 USE_EXPAND(APPLET(expand, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_EXPR(APPLET(expr, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
diff --git a/include/usage.h b/include/usage.h
index 57a9f99..632598f 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -127,6 +127,19 @@
        "$ basename /foo/bar.txt .txt\n" \
        "bar"
 
+#define esplash_trivial_usage \
+       "-s IMGFILE [-c] [-d DEV] [-i INIFILE] [-f CMD]"
+#define esplash_full_usage "\n\n" \
+       "Options:\n" \
+     "\n	-s	Image" \
+     "\n	-c	Hide cursor" \
+     "\n	-d	Framebuffer device (default /dev/fb0)" \
+     "\n	-i	Config file (var=value):" \
+     "\n			BAR_LEFT,BAR_TOP,BAR_WIDTH,BAR_HEIGHT" \
+     "\n			BAR_COLOR" \
+     "\n	-f	Control pipe (else exit after drawing image)" \
+     "\n			commands: 'NN' (% for progress bar) or 'exit'" \
+
 #define fbsplash_trivial_usage \
        "-s IMGFILE [-c] [-d DEV] [-i INIFILE] [-f CMD]"
 #define fbsplash_full_usage "\n\n" \
@@ -140,7 +153,7 @@
      "\n	-f	Control pipe (else exit after drawing image)" \
      "\n			commands: 'NN' (% for progress bar) or 'exit'" \
 
-#define brctl_trivial_usage \
+#define brctl_trivial_usage                     \
        "COMMAND [BRIDGE [INTERFACE]]"
 #define brctl_full_usage "\n\n" \
        "Manage ethernet bridges.\n" \
diff --git a/miscutils/Config.in b/miscutils/Config.in
index 0c80ae6..ca9d811 100644
--- a/miscutils/Config.in
+++ b/miscutils/Config.in
@@ -202,6 +202,25 @@ config FEATURE_EJECT_SCSI
 	  Add the -s option to eject, this allows to eject SCSI-Devices and
 	  usb-storage devices.
 
+config ESPLASH
+	bool "esplash"
+	default n
+	help
+	  Shows splash image and progress bar on 8bpp framebuffer device.
+	  Can be used during boot phase of an embedded device. ~2kb.
+	  Usage:
+	  - put somewhere esplash.cfg file and an image in framebuffer's format
+	    (possibly compressed: .gz, .bz2 and .lzma are recognized)
+	  - $ setsid esplash [params] &
+	    -c: hide cursor
+	    -d /dev/fbN: framebuffer device (if not /dev/fb0)
+	    -s path_to_image_file
+	    -i path_to_cfg_file (can be "-" for stdin)
+	    -f path_to_fifo (can be "-" for stdin)
+	  - commands for fifo:
+	    "NN" (ASCII decimal number) - percentage to show on progress bar
+	    "exit" - well you guessed it
+
 config FBSPLASH
 	bool "fbsplash"
 	default n
diff --git a/miscutils/Kbuild b/miscutils/Kbuild
index c12b12d..f43e074 100644
--- a/miscutils/Kbuild
+++ b/miscutils/Kbuild
@@ -14,6 +14,7 @@ lib-$(CONFIG_CRONTAB)     += crontab.o
 lib-$(CONFIG_DC)          += dc.o
 lib-$(CONFIG_DEVFSD)      += devfsd.o
 lib-$(CONFIG_EJECT)       += eject.o
+lib-$(CONFIG_ESPLASH)     += esplash.o
 lib-$(CONFIG_FBSPLASH)    += fbsplash.o
 lib-$(CONFIG_HDPARM)      += hdparm.o
 lib-$(CONFIG_INOTIFYD)    += inotifyd.o
diff --git a/miscutils/esplash.c b/miscutils/esplash.c
new file mode 100644
index 0000000..538654e
--- /dev/null
+++ b/miscutils/esplash.c
@@ -0,0 +1,288 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2008 Mikhail Gusarov <dottedmag@dottedmag.net>
+ *
+ * Based on fbsplash.c by Michele Sanges <michele.sanges@otomelara.it>,
+ * <michele.sanges@gmail.it>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ *
+ * Usage:
+ * - put somewhere esplash.cfg file and an image (fb dump, possibly compressed).
+ * - run applet: $ setsid esplash [params] &
+ *      -c: hide cursor
+ *      -d /dev/fbN: framebuffer device (if not /dev/fb0)
+ *      -s path_to_image_file
+ *      -i path_to_cfg_file
+ *      -f path_to_fifo (can be "-" for stdin)
+ * - commands for fifo:
+ *   "NN" (ASCII decimal number) - percentage to show on progress bar.
+ *   "exit" (or just close fifo) - well you guessed it.
+ */
+
+#include "libbb.h"
+#include <linux/fb.h>
+
+#define CONFIG_OPTIONS 6
+
+struct globals {
+	unsigned char *addr;	// pointer to framebuffer memory
+	unsigned ns[CONFIG_OPTIONS];	// n-parameters
+	unsigned last_percent;	// boot percent displayed last time
+	const char *image_filename;
+	const char *fb_device;
+	struct fb_var_screeninfo scr_var;
+	struct fb_fix_screeninfo scr_fix;
+};
+#define G (*ptr_to_globals)
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+} while (0)
+
+#define nbar_width	ns[0]	// progress bar width
+#define nbar_height	ns[1]	// progress bar height
+#define nbar_posx	ns[2]	// progress bar horizontal position
+#define nbar_posy	ns[3]	// progress bar vertical position
+#define nbar_col	ns[4]	// progress bar color
+#define screen_orientation	ns[5]	// screen orientation
+
+/**
+ * Draw filled rectangle on framebuffer
+ * \param from_x,from_y upper left position
+ * \param to_x,to_y down right position, not including
+ * \param n color
+ */
+static void fb_drawfullrectangle(int from_x, int from_y, int to_x, int to_y,
+	unsigned char n)
+{
+	int cnt1, cnt2, nypos;
+	unsigned char *ptr;
+
+	cnt1 = to_y - from_y;
+	nypos = from_y;
+	do {
+		ptr = G.addr + (nypos * G.scr_var.xres + from_x);
+		cnt2 = to_x - from_x;
+		do {
+			*ptr++ = n;
+		} while (--cnt2 > 0);
+
+		nypos++;
+	} while (--cnt1 > 0);
+}
+
+
+/**
+ *	Draw a progress bar on framebuffer
+ * \param percent percentage of loading
+ */
+static void fb_drawprogressbar(unsigned percent)
+{
+	int x, x2;
+
+	// [from_x, to_x)
+	int from_x = G.nbar_posx + G.nbar_width * G.last_percent / 100;
+	int to_x = G.nbar_posx + G.nbar_width * percent / 100;
+
+	// [from_y, to_y)
+	int from_y = G.nbar_posy;
+	int to_y = G.nbar_posy + G.nbar_height;
+
+	if(percent <= G.last_percent)
+		return;
+
+	switch(G.screen_orientation) {
+		case 90:
+			// not implemented
+			break;
+		case 180:
+			// not implemented
+			break;
+		case 270:
+			x = from_x;
+			x2 = to_x;
+			from_x = G.scr_var.xres - to_y;
+			to_x = G.scr_var.xres - from_y;
+			from_y = x;
+			to_y = x2;
+			break;
+	}
+
+	fb_drawfullrectangle(from_x, from_y, to_x, to_y, G.nbar_col);
+
+	G.last_percent = percent;
+}
+
+/**
+ *	Open and initialize the framebuffer device
+ * \param *strfb_device pointer to framebuffer device
+ */
+static void fb_open(const char *strfb_device)
+{
+	char *buffer, *p;
+	int fb_size, cnt;
+
+	int fbfd = xopen(strfb_device, O_RDWR);
+	int themefd = open_zipped(G.image_filename);
+
+	// framebuffer properties
+	xioctl(fbfd, FBIOGET_VSCREENINFO, &G.scr_var);
+	xioctl(fbfd, FBIOGET_FSCREENINFO, &G.scr_fix);
+	fb_size = G.scr_var.xres * G.scr_var.yres;
+
+	if (G.scr_var.bits_per_pixel != 8)
+		bb_error_msg_and_die("only 8 bpp is supported");
+
+	// map the device in memory
+	G.addr = mmap(NULL,
+			fb_size,
+			PROT_WRITE, MAP_SHARED, fbfd, 0);
+	if (G.addr == MAP_FAILED)
+		bb_perror_msg_and_die("can't mmap %s", strfb_device);
+	close(fbfd);
+
+	buffer = mmap(NULL, fb_size,
+			PROT_READ | PROT_WRITE,
+			MAP_PRIVATE | MAP_ANON,
+			/* ignored: */ -1, 0);
+	if (buffer == MAP_FAILED)
+		buffer = alloca(fb_size);
+
+	p = buffer;
+	cnt = 0;
+	while(1) {
+		ssize_t rd;
+
+		rd = safe_read(themefd, p, (fb_size - cnt) > 4096 ? 4096 : (fb_size - cnt));
+
+		if(rd > 0) {
+			p += rd;
+			cnt += rd;
+		}
+
+		if(fb_size == cnt) {
+			memcpy(G.addr, buffer, fb_size);
+
+			p = buffer;
+			cnt = 0;
+		}
+
+		if(rd <= 0)
+			break;
+	}
+
+	munmap(buffer, fb_size);
+
+	close(themefd);
+}
+
+/**
+ *	Parse configuration file
+ * \param *cfg_filename name of the configuration file
+ */
+static void init(const char *cfg_filename)
+{
+	static const char const param_names[] ALIGN1 =
+		"BAR_WIDTH\0" "BAR_HEIGHT\0"
+		"BAR_LEFT\0" "BAR_TOP\0"
+		"BAR_COLOR\0" "SCREEN_ORIENTATION\0"
+		"IMAGE\0" "FB\0"
+		;
+	char *token[2];
+	parser_t *parser = config_open2(cfg_filename, xfopen_stdin);
+	while (config_read(parser, token, 2, 2, "#=",
+				    (PARSE_NORMAL | PARSE_MIN_DIE) & ~(PARSE_TRIM | PARSE_COLLAPSE))) {
+		int i = index_in_strings(param_names, token[0]);
+		if (i < 0)
+			bb_error_msg_and_die("syntax error: '%s'", token[0]);
+		if (i >= 0 && i < CONFIG_OPTIONS) {
+			unsigned val = xatoi_u(token[1]);
+			G.ns[i] = val;
+		} else if(i == 6) {
+			if(G.image_filename == NULL || G.image_filename[0] == '\0')
+				G.image_filename = strdup(token[1]);
+		} else if(i == 7) {
+			if(G.fb_device == NULL || G.fb_device[0] == '\0')
+				G.fb_device = strdup(token[1]);
+		}
+	}
+	config_close(parser);
+}
+
+
+int esplash_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int esplash_main(int argc UNUSED_PARAM, char **argv)
+{
+	const char *cfg_filename, *fifo_filename;
+	FILE *fp = fp; // for compiler
+	char *num_buf;
+	unsigned num;
+	bool bCursorOff;
+
+	INIT_G();
+
+	// parse command line options
+	cfg_filename = NULL;
+	fifo_filename = NULL;
+
+	bCursorOff = 1 & getopt32(argv, "cs:d:i:f:",
+			&G.image_filename, &G.fb_device, &cfg_filename, &fifo_filename);
+
+	// parse configuration file
+	if (cfg_filename)
+		init(cfg_filename);
+
+	// We must have -s IMG
+	if (!G.image_filename)
+		bb_show_usage();
+
+	if (fifo_filename && bCursorOff) {
+		// hide cursor (BEFORE any fb ops)
+		full_write(STDOUT_FILENO, "\x1b" "[?25l", 6);
+	}
+
+	if(G.fb_device == NULL || G.fb_device[0] == '\0')
+		G.fb_device = "/dev/fb0";
+
+	fb_open(G.fb_device);
+
+	if (!fifo_filename)
+		return EXIT_SUCCESS;
+
+	fp = xfopen_stdin(fifo_filename);
+	if (fp != stdin) {
+		// For named pipes, we want to support this:
+		//  mkfifo cmd_pipe
+		//  esplash -f cmd_pipe .... &
+		//  ...
+		//  echo 33 >cmd_pipe
+		//  ...
+		//  echo 66 >cmd_pipe
+		// This means that we don't want esplash to get EOF
+		// when last writer closes input end.
+		// The simplest way is to open fifo for writing too
+		// and become an additional writer :)
+		open(fifo_filename, O_WRONLY); // errors are ignored
+	}
+
+	fb_drawprogressbar(0);
+	// Block on read, waiting for some input.
+	// Use of <stdio.h> style I/O allows to correctly
+	// handle a case when we have many buffered lines
+	// already in the pipe
+	while ((num_buf = xmalloc_fgetline(fp)) != NULL) {
+		if (strncmp(num_buf, "exit", 4) == 0) {
+			break;
+		}
+		num = atoi(num_buf);
+		if (isdigit(num_buf[0]) && (num <= 100)) {
+			fb_drawprogressbar(num);
+		}
+		free(num_buf);
+	}
+
+	if (bCursorOff) // restore cursor
+		full_write(STDOUT_FILENO, "\x1b" "[?25h", 6);
+
+	return EXIT_SUCCESS;
+}
diff --git a/miscutils/esplash.cfg b/miscutils/esplash.cfg
new file mode 100644
index 0000000..b6cf607
--- /dev/null
+++ b/miscutils/esplash.cfg
@@ -0,0 +1,9 @@
+# progress bar position
+BAR_LEFT=170
+BAR_TOP=300
+BAR_WIDTH=300
+BAR_HEIGHT=20
+# progress bar color
+BAR_R=80
+BAR_G=80
+BAR_B=130
