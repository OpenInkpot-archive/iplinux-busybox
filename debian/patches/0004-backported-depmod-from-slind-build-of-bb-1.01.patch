From d9255f459cd7acf61fc8681cc0d668ce2ea777e8 Mon Sep 17 00:00:00 2001
From: Alexander Shishkin <virtuoso@slind.org>
Date: Tue, 31 Jul 2007 13:49:14 +0400
Subject: [PATCH] backported depmod from slind build of bb 1.01

This is quickly hacked up from old version found among debian
patches against bb 1.01, later found in slind build of busybox.
Badly requires trimming down.

Signed-off-by: Alexander Shishkin <virtuoso@slind.org>
---
 include/applets.h                 |    1 +
 include/usage.h                   |    3 +
 modutils/Config.in                |    6 +
 modutils/Kbuild                   |    1 +
 modutils/depmod.c                 |  184 +++++++++++
 modutils/modutils.h               |   28 ++
 modutils/obj-2.6/depmod.c         |  623 +++++++++++++++++++++++++++++++++++++
 modutils/obj-2.6/depmod.h         |   58 ++++
 modutils/obj-2.6/list.h           |  238 ++++++++++++++
 modutils/obj-2.6/moduleops.c      |   22 ++
 modutils/obj-2.6/moduleops.h      |   27 ++
 modutils/obj-2.6/moduleops_core.c |  169 ++++++++++
 modutils/obj-2.6/zlibsupport.c    |   40 +++
 modutils/obj-2.6/zlibsupport.h    |   20 ++
 14 files changed, 1420 insertions(+), 0 deletions(-)
 create mode 100644 modutils/depmod.c
 create mode 100644 modutils/modutils.h
 create mode 100644 modutils/obj-2.6/depmod.c
 create mode 100644 modutils/obj-2.6/depmod.h
 create mode 100644 modutils/obj-2.6/list.h
 create mode 100644 modutils/obj-2.6/moduleops.c
 create mode 100644 modutils/obj-2.6/moduleops.h
 create mode 100644 modutils/obj-2.6/moduleops_core.c
 create mode 100644 modutils/obj-2.6/zlibsupport.c
 create mode 100644 modutils/obj-2.6/zlibsupport.h

diff --git a/include/applets.h b/include/applets.h
index b5e1e4c..451d231 100644
--- a/include/applets.h
+++ b/include/applets.h
@@ -111,6 +111,7 @@ USE_DD(APPLET_NOEXEC(dd, dd, _BB_DIR_BIN, _BB_SUID_NEVER, dd))
 USE_DEALLOCVT(APPLET(deallocvt, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_DELGROUP(APPLET_ODDNAME(delgroup, deluser, _BB_DIR_BIN, _BB_SUID_NEVER, delgroup))
 USE_DELUSER(APPLET(deluser, _BB_DIR_BIN, _BB_SUID_NEVER))
+USE_DEPMOD(APPLET(depmod, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_DEVFSD(APPLET(devfsd, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_DF(APPLET(df, _BB_DIR_BIN, _BB_SUID_NEVER))
 USE_APP_DHCPRELAY(APPLET(dhcprelay, _BB_DIR_USR_SBIN, _BB_SUID_NEVER))
diff --git a/include/usage.h b/include/usage.h
index a17f5b1..eb0ddcd 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -399,6 +399,9 @@
 #define bbconfig_full_usage \
        "Print the config file which built busybox"
 
+#define depmod_trivial_usage \
+       "DEPMOD USAGE IS TRIVIAL"
+
 #define bbsh_trivial_usage \
        "[FILE]...\n" \
        "or: bbsh -c command [args]..."
diff --git a/modutils/Config.in b/modutils/Config.in
index 6a69567..0fa611d 100644
--- a/modutils/Config.in
+++ b/modutils/Config.in
@@ -5,6 +5,12 @@
 
 menu "Linux Module Utilities"
 
+config DEPMOD
+	bool "depmod"
+	default n
+	help
+	  depmod is the shit!
+
 config INSMOD
 	bool "insmod"
 	default n
diff --git a/modutils/Kbuild b/modutils/Kbuild
index cff02b4..699fe7d 100644
--- a/modutils/Kbuild
+++ b/modutils/Kbuild
@@ -5,6 +5,7 @@
 # Licensed under the GPL v2, see the file LICENSE in this tarball.
 
 lib-y:=
+lib-$(CONFIG_DEPMOD)		+= obj-2.6/depmod.o obj-2.6/zlibsupport.o obj-2.6/moduleops.o depmod.o
 lib-$(CONFIG_INSMOD)		+= insmod.o
 lib-$(CONFIG_LSMOD)		+= lsmod.o
 lib-$(CONFIG_MODPROBE)		+= modprobe.o
diff --git a/modutils/depmod.c b/modutils/depmod.c
new file mode 100644
index 0000000..c3d84a3
--- /dev/null
+++ b/modutils/depmod.c
@@ -0,0 +1,184 @@
+/*
+ * depmod
+ *
+ * Create dependency file for modprobe, the kernel loadable modules loader.
+ *
+ * Copyright 1994, 1995, 1996, 1997 Jacques Gelinas <jack@solucorp.qc.ca>
+ * Additional modifications: Björn Ekwall <bj0rn@blox.se> February, March 1999
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <assert.h>
+#include <string.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <limits.h>
+#include <elf.h>
+
+#include "busybox.h"
+#include "modutils.h"
+
+static int get_kernel_version(char *str)
+{
+       char *p, *q;
+       int a, b, c;
+        struct utsname uts_info;
+
+       if (uname (&uts_info))
+               return -1;
+
+       strncpy(str, uts_info.release, STRVERSIONLEN-1);
+       str[STRVERSIONLEN-1] = '\0';
+       p = str;
+
+       a = strtoul(p, &p, 10);
+       if (*p != '.')
+               return -1;
+       b = strtoul(p + 1, &p, 10);
+       if (*p != '.')
+               return -1;
+       c = strtoul(p + 1, &q, 10);
+       if (p + 1 == q)
+               return -1;
+
+       return a << 16 | b << 8 | c;
+}
+
+int depmod_main(int argc, char **argv);
+int depmod_main(int argc, char **argv)
+{
+	int ret = -1;
+	int stdmode = 0;
+	int err = 0;
+	int o;
+	char *file_syms = NULL;
+	char *conf_file = NULL;
+	char *base_dir = "";
+	char *module_dir = NULL;
+
+	while ((o = getopt(argc, argv, "aAb:C:eF:hnqsvVru")) != EOF) {
+		switch (o) {
+			case 'A':
+			case 'a':
+				flag_quick = o == 'A';
+				stdmode = 1;	/* Probe standard directory */
+				break;		/* using the config file */
+
+			case 'b':
+				base_dir = optarg;
+				break;
+
+			case 'C':
+				conf_file = optarg;
+				break;
+
+			case 'e':
+				flag_showerror = 1;
+				break;
+
+			case 'F':
+				file_syms = optarg;
+				break;
+
+			case 'h':
+				return 0;
+				break;
+
+			case 'n':
+				flag_dry = 1;
+				break;
+
+			case 'q':
+				flag_quiet = 1;
+				break;
+
+			case 'u':
+				flag_unresolved_error = 1;
+				break;
+
+			default:
+				err = 1;
+				break;
+		}
+	}
+
+	if (err) {
+		bb_error_msg("Aborting");
+		return EXIT_FAILURE;
+	}
+	argc -= optind;
+	argv += optind;
+
+        k_version = get_kernel_version(k_strversion);
+
+	if (k_version != -1) {
+		char tmdn[FILENAME_MAX];
+		char real_module_dir[FILENAME_MAX];
+
+		snprintf(tmdn, FILENAME_MAX, "%s" _PATH_MODULES "/%s/", base_dir, k_strversion);
+		if (realpath (tmdn, real_module_dir) == NULL)
+			module_dir = tmdn;
+		else
+			module_dir = real_module_dir;
+	}
+	else
+		return EXIT_FAILURE;
+
+	if (k_version > MODUTILS_MINIMAL_VERSION_2_6)
+		ret = depmod_main_2_6(argc, argv, stdmode || argc == 0, file_syms, base_dir, module_dir);
+
+	return ret;
+}
+
+/*
+ * Rusty blows
+ */
+
+#include "libbb.h"
+
+#if ENABLE_GETOPT_LONG
+#include <getopt.h>
+
+static const char depmod_longopts[] =
+	"all\0"     No_argument "a"
+	"quick\0"   No_argument "A"
+	"errsyms\0" No_argument "e"
+	"help\0"    No_argument "h"
+	"show\0"    No_argument "n"
+	"dry-run\n" No_argument "d"
+	"quiet\0"   No_argument "q"
+	;
+#endif
+
+#define OPT_all     0x01
+#define OPT_quick   0x02
+#define OPT_errsyms 0x04
+#define OPT_help    0x08
+#define OPT_show    0x10
+#define OPT_dryrun  0x20
+#define OPT_quiet   0x40
+
diff --git a/modutils/modutils.h b/modutils/modutils.h
new file mode 100644
index 0000000..423d1ee
--- /dev/null
+++ b/modutils/modutils.h
@@ -0,0 +1,28 @@
+#define _PATH_MODULES	"/lib/modules/"
+#define MODULE_DIR	"/lib/modules/"
+#define STRVERSIONLEN	32
+
+/* FIXME: place definitions here for now (depmod.c is the
+ * only user of those) */
+/*extern*/int k_version;
+/*extern*/char k_strversion[STRVERSIONLEN];
+
+/* temporary */
+/*extern*/int flag_force_load;
+/*extern*/int flag_autoclean;
+/*extern*/int flag_verbose;
+/*extern*/int flag_quiet;
+/*extern*/int flag_export;
+/*extern*/int flag_unresolved_error;
+/*extern*/int flag_showerror;
+/*extern*/int flag_quick;
+/*extern*/int flag_dry;
+
+/*int get_kernel_version(char str[STRVERSIONLEN]);*/
+
+/*extern int depmod_main_2_4(int argc, char *argv[], int all, const char *system_map, const char *base_dir, const char *module_dir, const char *file_syms);*/
+extern int depmod_main_2_6(int argc, char *argv[], int all, const char *system_map, const char *base_dir, const char *module_dir);
+/*int insmod_main_2_4(int fp, int argc, char **argv, char *m_name, char *m_filename);*/
+
+#define MODUTILS_MINIMAL_VERSION_2_4 0x20100
+#define MODUTILS_MINIMAL_VERSION_2_6 0x20500
diff --git a/modutils/obj-2.6/depmod.c b/modutils/obj-2.6/depmod.c
new file mode 100644
index 0000000..5f1b5a5
--- /dev/null
+++ b/modutils/obj-2.6/depmod.c
@@ -0,0 +1,623 @@
+/* New simplified depmod without backwards compat stuff and not
+   requiring ksyms.
+
+   (C) 2002 Rusty Russell IBM Corporation
+ */
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <elf.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/mman.h>
+
+#include "busybox.h"
+
+#include "depmod.h"
+#include "moduleops.h"
+#include "zlibsupport.h"
+
+/* I hate strcmp. */
+#define streq(a,b) (strcmp((a),(b)) == 0)
+
+const int verbose = 0;
+const int doing_stdout = 0;
+static unsigned int skipchars;
+
+void *do_nofail(void *ptr, const char *file, int line, const char *expr)
+{
+	if (!ptr) {
+		bb_error_msg_and_die("Memory allocation failure %s line %d: %s.\n",
+		      file, line, expr);
+	}
+	return ptr;
+}
+
+#define SYMBOL_HASH_SIZE 1024
+struct symbol
+{
+	struct symbol *next;
+	struct module *owner;
+	char name[0];
+};
+
+static struct symbol *symbolhash[SYMBOL_HASH_SIZE];
+
+/* This is based on the hash agorithm from gdbm, via tdb */
+static inline unsigned int tdb_hash(const char *name)
+{
+	unsigned value;	/* Used to compute the hash value.  */
+	unsigned   i;	/* Used to cycle through random values. */
+
+	/* Set the initial value from the key size. */
+	for (value = 0x238F13AF * strlen(name), i=0; name[i]; i++)
+		value = (value + (((unsigned char *)name)[i] << (i*5 % 24)));
+
+	return (1103515243 * value + 12345);
+}
+
+void add_symbol(const char *name, struct module *owner)
+{
+	unsigned int hash;
+	struct symbol *new = NOFAIL(malloc(sizeof *new + strlen(name) + 1));
+
+	new->owner = owner;
+	strcpy(new->name, name);
+
+	hash = tdb_hash(name) % SYMBOL_HASH_SIZE;
+	new->next = symbolhash[hash];
+	symbolhash[hash] = new;
+}
+
+static int print_unknown;
+
+struct module *find_symbol(const char *name, const char *modname, int weak)
+{
+	struct symbol *s;
+
+	/* For our purposes, .foo matches foo.  PPC64 needs this. */
+	if (name[0] == '.')
+		name++;
+
+	for (s = symbolhash[tdb_hash(name) % SYMBOL_HASH_SIZE]; s; s=s->next) {
+		if (streq(s->name, name))
+			return s->owner;
+	}
+
+	if (print_unknown && !weak)
+		bb_error_msg("%s needs unknown symbol %s\n", modname, name);
+
+	return NULL;
+}
+
+void add_dep(struct module *mod, struct module *depends_on)
+{
+	unsigned int i;
+
+	for (i = 0; i < mod->num_deps; i++)
+		if (mod->deps[i] == depends_on)
+			return;
+
+	mod->deps = realloc(mod->deps, sizeof(mod->deps[0])*(mod->num_deps+1));
+	mod->deps[mod->num_deps++] = depends_on;
+}
+
+static void load_system_map(const char *filename)
+{
+	FILE *system_map;
+	char line[10240];
+
+	system_map = fopen(filename, "r");
+	if (!system_map)
+		bb_error_msg_and_die("Could not open '%s': %s\n", filename, strerror(errno));
+
+	/* eg. c0294200 R __ksymtab_devfs_alloc_devnum */
+	while (fgets(line, sizeof(line)-1, system_map)) {
+		char *ptr;
+
+		/* Snip \n */
+		ptr = strchr(line, '\n');
+		*ptr = '\0';
+
+		ptr = strchr(line, ' ');
+		if (!ptr || !(ptr = strchr(ptr + 1, ' ')))
+			continue;
+
+		/* Covers gpl-only and normal symbols. */
+		if (strncmp(ptr+1, "__ksymtab_", strlen("__ksymtab_")) == 0)
+			add_symbol(ptr+1+strlen("__ksymtab_"), NULL);
+	}
+
+	/* __this_module is magic inserted by kernel loader. */
+	add_symbol("__this_module", NULL);
+	/* On S390, this is faked up too */
+	add_symbol("_GLOBAL_OFFSET_TABLE_", NULL);
+}
+
+static struct option options[] = { { "all", 0, NULL, 'a' },
+				   { "quick", 0, NULL, 'A' },
+				   { "basedir", 1, NULL, 'b' },
+				   { "errsyms", 0, NULL, 'e' },
+				   { "filesyms", 1, NULL, 'F' },
+				   { "help", 0, NULL, 'h' },
+				   { "show", 0, NULL, 'n' },
+				   { "dry-run", 0, NULL, 'n' },
+				   { "quiet", 0, NULL, 'q' },
+				   { "root", 0, NULL, 'r' },
+				   { "unresolved-error", 0, NULL, 'u' },
+				   { "verbose", 0, NULL, 'v' },
+				   { "version", 0, NULL, 'V' },
+				   /* Obsolete, but we need to parse it. */
+				   { "config", 1, NULL, 'C' },
+				   { NULL, 0, NULL, 0 } };
+
+/* Version number or module name?  Don't assume extension. */
+static int is_version_number(const char *version)
+{
+	unsigned int dummy;
+
+	return (sscanf(version, "%u.%u.%u", &dummy, &dummy, &dummy) == 3);
+}
+
+static int old_module_version(const char *version)
+{
+	/* Expect three part version. */
+	unsigned int major, sub, minor;
+
+	sscanf(version, "%u.%u.%u", &major, &sub, &minor);
+
+	if (major > 2) return 0;
+	if (major < 2) return 1;
+
+	/* 2.x */
+	if (sub > 5) return 0;
+	if (sub < 5) return 1;
+
+	/* 2.5.x */
+	if (minor >= 48) return 0;
+	return 1;
+}
+
+static void exec_old_depmod(char *argv[])
+{
+	char *sep;
+	char pathname[strlen(argv[0])+1];
+	char oldname[strlen("depmod") + strlen(argv[0]) + sizeof(".modutils")];
+
+	memset(pathname, 0, strlen(argv[0])+1);
+	sep = strrchr(argv[0], '/');
+	if (sep)
+		memcpy(pathname, argv[0], sep - argv[0]+1);
+	sprintf(oldname, "%s%s.modutils", pathname, "depmod");
+
+	/* Recursion detection: we need an env var since we can't
+	   change argv[0] (as older modutils uses it to determine
+	   behavior). */
+	if (getenv("MODULE_RECURSE"))
+		return;
+	setenv("MODULE_RECURSE", "y", 0);
+
+	execvp(oldname, argv);
+	fprintf(stderr,
+		"Version requires old depmod, but couldn't run %s: %s\n",
+		oldname, strerror(errno));
+	exit(2);
+}
+
+static int ends_in(const char *name, const char *ext)
+{
+	unsigned int namelen, extlen;
+
+	/* Grab lengths */
+	namelen = strlen(name);
+	extlen = strlen(ext);
+
+	if (namelen < extlen) return 0;
+
+	if (streq(name + namelen - extlen, ext))
+		return 1;
+	return 0;
+}
+
+static struct module *grab_module(const char *_dirname,
+				  const char *filename,
+				  struct module *next)
+{
+	struct module *new;
+
+	new = NOFAIL(malloc(sizeof(*new)
+			    + strlen(_dirname) + 1 + strlen(filename) + 1));
+	sprintf(new->pathname, "%s/%s", _dirname, filename);
+	INIT_LIST_HEAD(&new->dep_list);
+
+	new->data = grab_file(new->pathname, &new->len);
+	if (!new->data) {
+		bb_error_msg("Can't read module %s: %s\n",
+		     new->pathname, strerror(errno));
+		goto fail_data;
+	}
+
+	/* "\177ELF" <byte> where byte = 001 for 32-bit, 002 for 64 */
+	if (memcmp(new->data, ELFMAG, SELFMAG) != 0) {
+		bb_error_msg("Module %s is not an elf object\n", new->pathname);
+		goto fail;
+	}
+
+	switch (((char *)new->data)[EI_CLASS]) {
+	case ELFCLASS32:
+		new->ops = &mod_ops32;
+		break;
+	case ELFCLASS64:
+		new->ops = &mod_ops64;
+		break;
+	default:
+		bb_error_msg("Module %s has elf unknown identifier %i\n",
+		     new->pathname, ((char *)new->data)[EI_CLASS]);
+		goto fail;
+	}
+	new->ops->load_symbols(new);
+
+	new->next = next;
+	return new;
+
+fail:
+	release_file(new->data, new->len);
+fail_data:
+	free(new);
+	return next;
+}
+
+struct module_traverse
+{
+	struct module_traverse *prev;
+	struct module *mod;
+};
+
+static int in_loop(struct module *mod, const struct module_traverse *traverse)
+{
+	const struct module_traverse *i;
+
+	for (i = traverse; i; i = i->prev) {
+		if (i->mod == mod)
+			return 1;
+	}
+	return 0;
+}
+
+/* Assume we are doing all the modules, so only report each loop once. */
+static void report_loop(const struct module *mod,
+			const struct module_traverse *traverse)
+{
+	const struct module_traverse *i;
+
+	/* Check that start is least alphabetically.  eg.  a depends
+	   on b depends on a will get reported for a, not b.  */
+	for (i = traverse->prev; i->prev; i = i->prev) {
+		if (strcmp(mod->pathname, i->mod->pathname) > 0)
+			return;
+	}
+
+	/* Is start in the loop?  If not, don't report now. eg. a
+	   depends on b which depends on c which depends on b.  Don't
+	   report when generating depends for a. */
+	if (mod != i->mod)
+		return;
+
+	bb_error_msg("Loop detected: %s ", mod->pathname);
+	for (i = traverse->prev; i->prev; i = i->prev)
+		fprintf(stderr, "needs %s ", basename(i->mod->pathname));
+	fprintf(stderr, "which needs %s again!\n", basename(mod->pathname));
+}
+
+/* This is damn slow, but loops actually happen, and we don't want to
+   just exit() and leave the user without any modules. */
+static int has_dep_loop(struct module *module, struct module_traverse *prev)
+{
+	unsigned int i;
+	struct module_traverse traverse = { .prev = prev, .mod = module };
+
+	if (in_loop(module, prev)) {
+		report_loop(module, &traverse);
+		return 1;
+	}
+
+	for (i = 0; i < module->num_deps; i++)
+		if (has_dep_loop(module->deps[i], &traverse))
+			return 1;
+	return 0;
+}
+
+/* Uniquifies and orders a dependency list. */
+static void order_dep_list(struct module *start, struct module *mod)
+{
+	unsigned int i;
+
+	for (i = 0; i < mod->num_deps; i++) {
+		/* If it was previously depended on, move it to the
+		   tail.  ie. if a needs b and c, and c needs b, we
+		   must order b after c. */
+		list_del(&mod->deps[i]->dep_list);
+		list_add_tail(&mod->deps[i]->dep_list, &start->dep_list);
+		order_dep_list(start, mod->deps[i]);
+	}
+}
+
+static void del_module(struct module **modules, struct module *delme)
+{
+	struct module **i;
+
+	/* Find pointer to it. */ 
+	for (i = modules; *i != delme; i = &(*i)->next);
+
+	*i = delme->next;
+}
+
+static void output_deps(struct module *modules,
+			FILE *out)
+{
+	struct module *i;
+
+	for (i = modules; i; i = i->next)
+		i->ops->calculate_deps(i, verbose);
+
+	/* Strip out loops. */
+ again:
+	for (i = modules; i; i = i->next) {
+		if (has_dep_loop(i, NULL)) {
+			bb_error_msg("Module %s ignored, due to loop\n",
+			     i->pathname + skipchars);
+			del_module(&modules, i);
+			goto again;
+		}
+	}
+
+	/* Now dump them out. */
+	for (i = modules; i; i = i->next) {
+		struct list_head *j, *tmp;
+		order_dep_list(i, i);
+
+		fprintf(out, "%s:", i->pathname + skipchars);
+		list_for_each_safe(j, tmp, &i->dep_list) {
+			struct module *dep
+				= list_entry(j, struct module, dep_list);
+			fprintf(out, " %s", dep->pathname + skipchars);
+			list_del_init(j);
+		}
+		fprintf(out, "\n");
+	}
+}
+
+static int smells_like_module(const char *name)
+{
+	return ends_in(name,".ko") || ends_in(name, ".ko.gz");
+}
+
+static struct module *grab_dir(const char *_dirname, struct module *next)
+{
+	DIR *dir;
+	struct dirent *dirent;
+
+	dir = opendir(_dirname);
+	if (!dir) {
+		bb_error_msg("Couldn't open directory %s: %s\n",
+		     _dirname, strerror(errno));
+		return next;
+	}
+
+	while ((dirent = readdir(dir)) != NULL) {
+		if (smells_like_module(dirent->d_name))
+			next = grab_module(_dirname, dirent->d_name, next);
+		else if (!streq(dirent->d_name, ".")
+			 && !streq(dirent->d_name, "..")) {
+			struct stat st;
+
+			char subdir[strlen(_dirname) + 1
+				   + strlen(dirent->d_name) + 1];
+			sprintf(subdir, "%s/%s", _dirname, dirent->d_name);
+			if (lstat(subdir, &st) != 0)
+				bb_error_msg("Couldn't stat %s: %s\n", subdir,
+				     strerror(errno));
+			else if (S_ISDIR(st.st_mode))
+				next = grab_dir(subdir, next);
+		}
+	}
+	closedir(dir);
+	return next;
+}
+
+/* Convert filename to the module name.  Works if filename == modname, too. */
+static void filename2modname(char *modname, const char *filename)
+{
+	const char *afterslash;
+	unsigned int i;
+
+	afterslash = strrchr(filename, '/');
+	if (!afterslash)
+		afterslash = filename;
+	else
+		afterslash++;
+
+	/* Convert to underscores, stop at first . */
+	for (i = 0; afterslash[i] && afterslash[i] != '.'; i++) {
+		if (afterslash[i] == '-')
+			modname[i] = '_';
+		else
+			modname[i] = afterslash[i];
+	}
+	modname[i] = '\0';
+}
+
+/* Simply dump hash table. */
+static void output_symbols(struct module *unused, FILE *out)
+{
+	unsigned int i;
+
+	fprintf(out, "# Aliases for symbols, used by symbol_request().\n");
+	for (i = 0; i < SYMBOL_HASH_SIZE; i++) {
+		struct symbol *s;
+
+		for (s = symbolhash[i]; s; s = s->next) {
+			if (s->owner) {
+				char modname[strlen(s->owner->pathname)+1];
+				filename2modname(modname, s->owner->pathname);
+				fprintf(out, "alias symbol:%s %s\n",
+					s->name, modname);
+			}
+		}
+	}
+}
+
+static const char *next_string(const char *string, unsigned long *secsize)
+{
+	/* Skip non-zero chars */
+	while (string[0]) {
+		string++;
+		if ((*secsize)-- <= 1)
+			return NULL;
+	}
+
+	/* Skip any zero padding. */
+	while (!string[0]) {
+		string++;
+		if ((*secsize)-- <= 1)
+			return NULL;
+	}
+	return string;
+}
+
+static void output_aliases(struct module *modules, FILE *out)
+{
+	struct module *i;
+	const char *p;
+	long size;
+
+	fprintf(out, "# Aliases extracted from modules themselves.\n");
+	for (i = modules; i; i = i->next) {
+		char modname[strlen(i->pathname)+1];
+
+		filename2modname(modname, i->pathname);
+
+		/* Grab from old-style .modalias section. */
+		for (p = i->ops->get_aliases(i, &size);
+		     p;
+		     p = next_string(p, &size))
+			fprintf(out, "alias %s %s\n", p, modname);
+
+		/* Grab form new-style .modinfo section. */
+		for (p = i->ops->get_modinfo(i, &size);
+		     p;
+		     p = next_string(p, &size)) {
+			if (strncmp(p, "alias=", strlen("alias=")) == 0)
+				fprintf(out, "alias %s %s\n",
+					p + strlen("alias="), modname);
+		}
+	}
+}
+
+struct depfile {
+	char *name;
+	void (*func)(struct module *, FILE *);
+};
+
+static struct depfile depfiles[] = {
+	{ "modules.dep", output_deps }, /* This is what we check for '-A'. */
+};
+
+/* If we can't figure it out, it's safe to say "true". */
+static int any_modules_newer(const char *_dirname, time_t mtime)
+{
+	DIR *dir;
+	struct dirent *dirent;
+
+	dir = opendir(_dirname);
+	if (!dir)
+		return 1;
+
+	while ((dirent = readdir(dir)) != NULL) {
+		struct stat st;
+		char file[strlen(_dirname) + 1 + strlen(dirent->d_name) + 1];
+
+		if (streq(dirent->d_name, ".") || streq(dirent->d_name, ".."))
+			continue;
+
+		sprintf(file, "%s/%s", _dirname, dirent->d_name);
+		if (lstat(file, &st) != 0)
+			return 1;
+
+		if (smells_like_module(dirent->d_name)) {
+			if (st.st_mtime > mtime)
+				return 1;
+		} else if (S_ISDIR(st.st_mode)) {
+			if (any_modules_newer(file, mtime))
+				return 1;
+		}
+	}
+	closedir(dir);
+	return 0;
+}
+
+static int depfile_out_of_date(const char *_dirname)
+{
+	struct stat st;
+	char depfile[strlen(_dirname) + 1 + strlen(depfiles[0].name) + 1];
+
+	sprintf(depfile, "%s/%s", _dirname, depfiles[0].name);
+
+	if (stat(depfile, &st) != 0)
+		return 1;
+
+	return any_modules_newer(_dirname, st.st_mtime);
+}
+
+int depmod_main_2_6(int argc, char *argv[], int all, const char *system_map, const char *base_dir, const char *_dirname)
+{
+	struct module *list = NULL;
+	int i;
+
+	/* We can't print unknowns without a System.map */
+	if (!system_map)
+		print_unknown = 0;
+	else
+		load_system_map(system_map);
+
+	if (!all) {
+		/* Do command line args. */
+		for (; argc; ++argv, --argc)
+			list = grab_module("", *argv, list);
+	} else {
+		list = grab_dir(_dirname, list);
+	}
+
+	for (i = 0; i < sizeof(depfiles)/sizeof(depfiles[0]); i++) {
+		FILE *out;
+		struct depfile *d = &depfiles[i];
+		char depname[strlen(_dirname) + 1 + strlen(d->name) + 1];
+		char tmpname[strlen(_dirname) + 1 + strlen(d->name) +
+						strlen(".temp") + 1];
+
+		sprintf(depname, "%s/%s", _dirname, d->name);
+		sprintf(tmpname, "%s/%s.temp", _dirname, d->name);
+		if (!doing_stdout) {
+			out = fopen(tmpname, "w");
+			if (!out)
+				bb_error_msg_and_die("Could not open %s for writing: %s\n",
+					tmpname, strerror(errno));
+		} else
+			out = stdout;
+		d->func(list, out);
+		if (!doing_stdout) {
+			fclose(out);
+			if (rename(tmpname, depname) < 0)
+				bb_error_msg_and_die("Could not rename %s into %s: %s\n",
+					tmpname, depname, strerror(errno));
+		}
+	}
+
+	return 0;
+}
diff --git a/modutils/obj-2.6/depmod.h b/modutils/obj-2.6/depmod.h
new file mode 100644
index 0000000..759cc99
--- /dev/null
+++ b/modutils/obj-2.6/depmod.h
@@ -0,0 +1,58 @@
+#ifndef MODINITTOOLS_DEPMOD_H
+#define MODINITTOOLS_DEPMOD_H
+#include "list.h"
+
+struct module;
+
+/* Functions provided by depmod.c */
+void fatal(const char *fmt, ...) __attribute__ ((noreturn,
+						 format (printf, 1, 2)));
+void warn(const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));
+void *do_nofail(void *ptr, const char *file, int line, const char *expr);
+#define NOFAIL(ptr)	do_nofail((ptr), __FILE__, __LINE__, #ptr)
+
+void add_symbol(const char *name, struct module *owner);
+struct module *find_symbol(const char *name, const char *modname, int weak);
+void add_dep(struct module *mod, struct module *depends_on);
+
+struct module
+{
+	/* Next module in list of all modules */
+	struct module *next;
+
+	/* 64 or 32 bit? */
+	struct module_ops *ops;
+
+	/* Dependencies: filled in by ops->calculate_deps() */
+	unsigned int num_deps;
+	struct module **deps;
+
+	/* Set while we are traversing dependencies */
+	struct list_head dep_list;
+
+	/* Tables extracted from module by ops->fetch_tables(). */
+	/* FIXME: Do other tables too --RR */
+	unsigned int pci_size;
+	void *pci_table;
+	unsigned int usb_size;
+	void *usb_table;
+	unsigned int ieee1394_size;
+	void *ieee1394_table;
+	unsigned int ccw_size;
+	void *ccw_table;
+	unsigned int pnp_size;
+	void *pnp_table;
+	unsigned int pnp_card_size;
+	unsigned int pnp_card_offset;
+	void *pnp_card_table;
+	unsigned int input_size;
+	void *input_table;
+
+	/* File contents and length. */
+	void *data;
+	unsigned long len;
+
+	char pathname[0];
+};
+
+#endif /* MODINITTOOLS_DEPMOD_H */
diff --git a/modutils/obj-2.6/list.h b/modutils/obj-2.6/list.h
new file mode 100644
index 0000000..28ad9f1
--- /dev/null
+++ b/modutils/obj-2.6/list.h
@@ -0,0 +1,238 @@
+/* Stolen from Linux Kernel Source's list.h -- GPL. */
+#ifndef _MODINITTOOLS_LIST_H
+#define _MODINITTOOLS_LIST_H
+
+#undef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ *
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is
+ * in an undefined state.
+ */
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add(list, head);
+}
+
+/**
+ * list_move_tail - delete from one list and add as another's tail
+ * @list: the entry to move
+ * @head: the head that will follow our entry
+ */
+static inline void list_move_tail(struct list_head *list,
+				  struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add_tail(list, head);
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static inline int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+static inline void __list_splice(struct list_head *list,
+				 struct list_head *head)
+{
+	struct list_head *first = list->next;
+	struct list_head *last = list->prev;
+	struct list_head *at = head->next;
+
+	first->prev = head;
+	head->next = first;
+
+	last->next = at;
+	at->prev = last;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static inline void list_splice(struct list_head *list, struct list_head *head)
+{
+	if (!list_empty(list))
+		__list_splice(list, head);
+}
+
+/**
+ * list_splice_init - join two lists and reinitialise the emptied list.
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ *
+ * The list at @list is reinitialised
+ */
+static inline void list_splice_init(struct list_head *list,
+				    struct list_head *head)
+{
+	if (!list_empty(list)) {
+		__list_splice(list, head);
+		INIT_LIST_HEAD(list);
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/**
+ * list_for_each_prev	-	iterate over a list backwards
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+	for (pos = (head)->prev; pos != (head); pos = pos->prev)
+        	
+/**
+ * list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+	     &pos->member != (head);					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#endif
diff --git a/modutils/obj-2.6/moduleops.c b/modutils/obj-2.6/moduleops.c
new file mode 100644
index 0000000..50acc57
--- /dev/null
+++ b/modutils/obj-2.6/moduleops.c
@@ -0,0 +1,22 @@
+/* The nasty work of reading 32 and 64-bit modules is in here. */
+#include <elf.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "depmod.h"
+#include "moduleops.h"
+
+#define PERBIT(x) x##32
+#define ElfPERBIT(x) Elf32_##x
+#define ELFPERBIT(x) ELF32_##x
+#include "moduleops_core.c"
+
+#undef PERBIT
+#undef ElfPERBIT
+#undef ELFPERBIT
+#define PERBIT(x) x##64
+#define ElfPERBIT(x) Elf64_##x
+#define ELFPERBIT(x) ELF64_##x
+#include "moduleops_core.c"
diff --git a/modutils/obj-2.6/moduleops.h b/modutils/obj-2.6/moduleops.h
new file mode 100644
index 0000000..6bb2b71
--- /dev/null
+++ b/modutils/obj-2.6/moduleops.h
@@ -0,0 +1,27 @@
+#ifndef MODINITTOOLS_MODULEOPS_H
+#define MODINITTOOLS_MODULEOPS_H
+#include <stdio.h>
+
+/* All the icky stuff to do with manipulating 64 and 32-bit modules
+   belongs here. */
+struct kernel_symbol32 {
+	char value[4];
+	char name[64 - 4];
+};
+
+struct kernel_symbol64 {
+	char value[8];
+	char name[64 - 8];
+};
+
+struct module_ops
+{
+	void (*load_symbols)(struct module *module);
+	void (*calculate_deps)(struct module *module, int verbose);
+	char *(*get_aliases)(struct module *module, unsigned long *size);
+	char *(*get_modinfo)(struct module *module, unsigned long *size);
+};
+
+extern struct module_ops mod_ops32, mod_ops64;
+
+#endif /* MODINITTOOLS_MODULEOPS_H */
diff --git a/modutils/obj-2.6/moduleops_core.c b/modutils/obj-2.6/moduleops_core.c
new file mode 100644
index 0000000..3561a31
--- /dev/null
+++ b/modutils/obj-2.6/moduleops_core.c
@@ -0,0 +1,169 @@
+/* Load the given section: NULL on error. */
+static void *PERBIT(load_section)(ElfPERBIT(Ehdr) *hdr,
+			    const char *secname,
+			    unsigned long *size)
+{
+	ElfPERBIT(Shdr) *sechdrs;
+	unsigned int i;
+	char *secnames;
+
+	/* Grab section headers and strings so we can tell who is who */
+	sechdrs = (void *)hdr + hdr->e_shoff;
+	secnames = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
+
+	/* Find the section they want */
+	for (i = 1; i < hdr->e_shnum; i++) {
+		if (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {
+			*size = sechdrs[i].sh_size;
+			return (void *)hdr + sechdrs[i].sh_offset;
+		}
+	}
+	*size = 0;
+	return NULL;
+}
+
+static void PERBIT(load_symbols)(struct module *module)
+{
+	struct PERBIT(kernel_symbol) *ksyms;
+	char *ksymstrings;
+	unsigned long i, size;
+
+	/* New-style: strings are in this section. */
+	ksymstrings = PERBIT(load_section)(module->data, "__ksymtab_strings",
+					   &size);
+	if (ksymstrings) {
+		unsigned int i = 0;
+		for (;;) {
+			/* Skip any zero padding. */
+			while (!ksymstrings[i])
+				if (++i >= size)
+					return;
+			add_symbol(ksymstrings+i, module);
+			i += strlen(ksymstrings+i);
+		}
+		/* GPL symbols too */
+		ksymstrings = PERBIT(load_section)(module->data,
+						   "__ksymtab_strings_gpl",
+						   &size);
+		for (;;) {
+			/* Skip any zero padding. */
+			while (!ksymstrings[i])
+				if (++i >= size)
+					return;
+			add_symbol(ksymstrings+i, module);
+			i += strlen(ksymstrings+i);
+		}
+		return;
+	}
+
+	/* Old-style. */
+	ksyms = PERBIT(load_section)(module->data, "__ksymtab", &size);
+	for (i = 0; i < size / sizeof(struct PERBIT(kernel_symbol)); i++)
+		add_symbol(ksyms[i].name, module);
+	ksyms = PERBIT(load_section)(module->data, "__gpl_ksymtab", &size);
+	for (i = 0; i < size / sizeof(struct PERBIT(kernel_symbol)); i++)
+		add_symbol(ksyms[i].name, module);
+}
+
+static char *PERBIT(get_aliases)(struct module *module, unsigned long *size)
+{
+	return PERBIT(load_section)(module->data, ".modalias", size);
+}
+
+static char *PERBIT(get_modinfo)(struct module *module, unsigned long *size)
+{
+	return PERBIT(load_section)(module->data, ".modinfo", size);
+}
+
+#ifndef STT_REGISTER
+#define STT_REGISTER    13              /* Global register reserved to app. */
+#endif
+
+/* Calculate the dependencies for this module */
+static void PERBIT(calculate_deps)(struct module *module, int verbose)
+{
+	unsigned int i;
+	unsigned long size;
+	char *strings;
+	ElfPERBIT(Sym) *syms;
+	ElfPERBIT(Ehdr) *hdr;
+	int handle_register_symbols;
+
+	strings = PERBIT(load_section)(module->data, ".strtab", &size);
+	syms = PERBIT(load_section)(module->data, ".symtab", &size);
+
+	if (!strings || !syms) {
+		warn("Couldn't find symtab and strtab in module %s\n",
+		     module->pathname);
+		return;
+	}
+
+	hdr = module->data;
+	handle_register_symbols = 0;
+	if (hdr->e_machine == EM_SPARC ||
+	    hdr->e_machine == EM_SPARCV9)
+		handle_register_symbols = 1;
+
+	module->num_deps = 0;
+	module->deps = NULL;
+	for (i = 1; i < size / sizeof(syms[0]); i++) {
+		if (syms[i].st_shndx == SHN_UNDEF) {
+			/* Look for symbol */
+			const char *name = strings + syms[i].st_name;
+			struct module *owner;
+			int weak;
+
+			/* Not really undefined: sparc gcc 3.3 creates
+                           U references when you have global asm
+                           variables, to avoid anyone else mising
+                           them. */
+			if (handle_register_symbols
+			    && (ELFPERBIT(ST_TYPE)(syms[i].st_info)
+				== STT_REGISTER))
+				continue;
+
+			weak = ELFPERBIT(ST_BIND)(syms[i].st_info) == STB_WEAK;
+			owner = find_symbol(name, module->pathname, weak);
+			if (owner) {
+				if (verbose)
+					printf("%s needs \"%s\": %s\n",
+					       module->pathname, name,
+					       owner->pathname);
+				add_dep(module, owner);
+			}
+		}
+	}
+}
+
+static void *PERBIT(deref_sym)(ElfPERBIT(Ehdr) *hdr, const char *name)
+{
+	unsigned int i;
+	unsigned long size;
+	char *strings;
+	ElfPERBIT(Sym) *syms;
+	ElfPERBIT(Shdr) *sechdrs;
+
+	sechdrs = (void *)hdr + hdr->e_shoff;
+	strings = PERBIT(load_section)(hdr, ".strtab", &size);
+	syms = PERBIT(load_section)(hdr, ".symtab", &size);
+
+	/* Don't warn again: we already have above */
+	if (!strings || !syms)
+		return NULL;
+
+	for (i = 0; i < size / sizeof(syms[0]); i++) {
+		if (strcmp(strings + syms[i].st_name, name) == 0) {
+			return (void *)hdr
+				+ sechdrs[syms[i].st_shndx].sh_offset
+				+ syms[i].st_value;
+		}
+	}
+	return NULL;
+}
+
+struct module_ops PERBIT(mod_ops) = {
+	.load_symbols	= PERBIT(load_symbols),
+	.calculate_deps	= PERBIT(calculate_deps),
+	.get_aliases	= PERBIT(get_aliases),
+	.get_modinfo	= PERBIT(get_modinfo),
+};
diff --git a/modutils/obj-2.6/zlibsupport.c b/modutils/obj-2.6/zlibsupport.c
new file mode 100644
index 0000000..a5a0d1c
--- /dev/null
+++ b/modutils/obj-2.6/zlibsupport.c
@@ -0,0 +1,40 @@
+/* Support for compressed modules.  Willy Tarreau <willy@meta-x.org>
+ * did the support for modutils, Andrey Borzenkov <arvidjaar@mail.ru>
+ * ported it to module-init-tools, and I said it was too ugly to live
+ * and rewrote it 8).
+ *
+ * (C) 2003 Rusty Russell, IBM Corporation.
+ */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+#include "zlibsupport.h"
+
+void *grab_file(const char *filename, unsigned long *size)
+{
+	int fd;
+	struct stat st;
+	void *map;
+
+	fd = open(filename, O_RDONLY, 0);
+	if (fd < 0)
+		return NULL;
+
+	fstat(fd, &st);
+	*size = st.st_size;
+	map = mmap(0, *size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
+	if (map == MAP_FAILED)
+		map = NULL;
+
+	close(fd);
+	return map;
+}
+
+void release_file(void *data, unsigned long size)
+{
+	munmap(data, size);
+}
diff --git a/modutils/obj-2.6/zlibsupport.h b/modutils/obj-2.6/zlibsupport.h
new file mode 100644
index 0000000..4657281
--- /dev/null
+++ b/modutils/obj-2.6/zlibsupport.h
@@ -0,0 +1,20 @@
+#ifndef _ZLIB_SUPPORT_H
+#define _ZLIB_SUPPORT_H
+
+/* Grab file.  Decompresses if that is supported.  Returns NULL on error. */
+extern void *grab_file(const char *filename, unsigned long *size);
+
+/* Free it up. */
+extern void release_file(void *data, unsigned long size);
+
+#endif /* _ZLIB_SUPPORT_H */
+#ifndef _ZLIB_SUPPORT_H
+#define _ZLIB_SUPPORT_H
+
+/* Grab file.  Decompresses if that is supported.  Returns NULL on error. */
+extern void *grab_file(const char *filename, unsigned long *size);
+
+/* Free it up. */
+extern void release_file(void *data, unsigned long size);
+
+#endif /* _ZLIB_SUPPORT_H */
-- 
1.5.1.2

